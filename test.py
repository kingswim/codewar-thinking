4   --> [3,1],[2,2],[2,1,1],[1,1,1,1]
3   --> [2,1],[1,1,1]
2   --> [1,1]
5   --> [4,1],[3,2]


都拆出来:
问题1:6能拆成 [3,2,1],3也能拆成[2,1],那么就产生重复.重复问题怎么解决
问题 2:怎么拆?

7 --> (n-1,1) (n-2,2) (n-3,3) (n-4,4) (n-5,5) (n-6,6)
但就这样的话，7也有问题，因为产生重复的构造

所以 用(6,1),(5,2),(4,3) 就行

[(i,n-i) for i in n/2]产生序对

然后计算这些数的prod,
(5,3)-->(2,3,3) --> 18  
(6,2)-->(3,3,2) --> 18
----------------------------------------
返回 n,average,median :
以5为例，是(5) (4,1)(3,2),(2,1,1,1),(3,1,1),(1,1,1,1,1),(2,2,1)

             5  4   6  2   3  1   4
            去重
             5  4  6  2 3 1
----------------------------------------
叶子需要cut ,就是都是1,1,1,1,1...的
----------------------------------------

n
第一步 : [(i,n-i) for i in n/2]产生序对，再拼上n   
第二步 :  找出 除叶子外的结构 ，并去重，返回 一个 元素是列表的列表
第三步 : 计算结果

第二步:
     def look_all_list(list1):
     '''
     对所有的list1分离，如果在memorization中的话就直接使用，没有就计算
     '''
         怎么计算
    对list1中的元素如果有就直接替换，如果没有就递规
